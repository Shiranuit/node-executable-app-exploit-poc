import EventEmitter from "events";
import { Worker } from "worker_threads";
import { ResolvablePromise } from "./ResolvablePromise";

export type WorkerTask<T> = {
    id: number;
    data: T;
};

export type TaskResult<T> = {
    id: number;
    result: T;
};

type WorkerFunc<T, U> = (args: any[]) => ((task: T) => U | Promise<U>);

type TaskStatus = "taskCompleted" | "taskRejected";
type ResolvedTask<T> = {
    id: number;
    status: TaskStatus;
    result: T;
};

type WorkerState = "idle" | "running";
type WorkerInstance = {
    id: number;
    state: WorkerState;
    worker: Worker;
};

export declare interface WorkerPool<T, U> {
    on(event: "taskCompleted", listener: (task: TaskResult<U>) => void): this;
    on(event: "taskRejected", listener: (task: TaskResult<Error>) => void): this;
};

export class WorkerPool<T, U> extends EventEmitter {
    private workers: WorkerInstance[] = [];
    private taskCountRunning: number = 0;
    private taskQueue: WorkerTask<T>[] = [];
    private id: number = 0;
    private runningTasks: Map<number, ResolvablePromise<U>> = new Map();
    private running: boolean = false;
    private waitForCompletion: boolean = false;
    private destroyed: boolean = false;

    constructor(workerCount: number, func: WorkerFunc<T, U>, args: any[] = []) {
        super();

        const workerCode = `
        const { parentPort } = require("worker_threads");

        const generator = ${func};
        const executor = generator(...process.argv);

        parentPort.on("message", async (task) => {
            try {
                const result = await executor(task.data);
                parentPort.postMessage({
                    id: task.id,
                    status: "taskCompleted",
                    result
                });
            } catch (e) {
                parentPort.postMessage({
                    id: task.id,
                    status: "taskRejected",
                    result: e
                });
            }
        });
        `;

        for (let i = 0; i < workerCount; i++) {
            const worker = new Worker(workerCode, { eval: true, argv: [...args] });
            this.workers.push({
                id: i,
                state: "idle",
                worker
            });

            const workers = this.workers;
            worker.on("message", (result: ResolvedTask<U>) => {
                const instance = workers[i];
                instance.state = "idle";
                this.taskCountRunning--;

                if (result.status === "taskRejected") {
                    this.emit("taskRejected", {
                        id: result.id,
                        result: result.result
                    });
                    const resolvablePromise = this.runningTasks.get(result.id);
                    if (resolvablePromise) {
                        resolvablePromise.reject(result.result);
                        this.runningTasks.delete(result.id);
                    }
                    return this.executeTask(instance);
                }

                this.emit("taskCompleted", {
                    id: result.id,
                    result: result.result
                });
                const resolvablePromise = this.runningTasks.get(result.id);
                if (resolvablePromise) {
                    resolvablePromise.resolve(result.result);
                    this.runningTasks.delete(result.id);
                }

                this.executeTask(instance);
            });
        }
    }

    private executeTask(worker: WorkerInstance): void {
        if (worker.state === "running") {
            return;
        }
        const task = this.taskQueue.shift();
        if (task) {
            worker.state = "running";
            this.taskCountRunning++;
            worker.worker.postMessage(task);
            this.emit("taskStarted", worker, task);
        }
    }

    private work() {
        if (this.destroyed) {
            return;
        }

        if (this.running || this.waitForCompletion) {
            for (let i = 0; i < this.workers.length; i++) {
                this.executeTask(this.workers[i]);
            };
            setTimeout(() => { this.work() })
        }
    }

    public start(): void {
        if (this.destroyed) {
            throw new Error("Worker pool is destroyed");
        }

        if (this.running || this.waitForCompletion) {
            return;
        }

        this.id = 0;
        this.waitForCompletion = false;
        this.taskQueue = [];
        this.running = true;

        this.work();
    }

    private async checkIsFinished(promise: ResolvablePromise<void>): Promise<void> {
        if (!this.waitForCompletion || this.destroyed) {
            return;
        }

        if (this.taskQueue.length === 0 && this.runningTasks.size === 0 && this.taskCountRunning === 0) {
            this.waitForCompletion = false;
            promise.resolve();
            return;
        }

        setTimeout(() => {
            this.checkIsFinished(promise);
        });
    }

    public async stop(waitForCompletion: boolean): Promise<void> {
        if (this.destroyed) {
            throw new Error("Worker pool is destroyed");
        }

        if (!this.running || this.waitForCompletion) {
            return;
        }
        this.running = false;

        if (!waitForCompletion) {
            return;
        }

        const promise = new ResolvablePromise<void>();
        this.waitForCompletion = true;
        this.checkIsFinished(promise);
        return promise.promise;
    }

    public run(task: T): number {
        if (this.destroyed) {
            throw new Error("Worker pool is destroyed");
        }

        if (!this.running) {
            return;
        }

        this.taskQueue.push({
            id: this.id,
            data: task
        });

        return this.id++;
    }

    public size(): number {
        return this.taskQueue.length;
    }

    public runningTasksCount(): number {
        return this.taskCountRunning;
    }

    public wait(): Promise<void> {
        if (this.destroyed) {
            throw new Error("Worker pool is destroyed");
        }

        if (!this.running || this.waitForCompletion) {
            return;
        }

        this.waitForCompletion = true;

        const promise = new ResolvablePromise<void>();
        this.checkIsFinished(promise);
        return promise.promise;
    }

    public isRunning(): boolean {
        return this.running;
    }

    public runAsync(task: T): Promise<U> {
        if (this.destroyed) {
            throw new Error("Worker pool is destroyed");
        }

        if (!this.running) {
            return;
        }

        this.taskQueue.push({
            id: this.id,
            data: task
        });
        const id = this.id++;
        const resolvablePromise = new ResolvablePromise<U>();
        this.runningTasks.set(id, resolvablePromise);
        return resolvablePromise.promise;
    }

    public destroy(): void {
        if (this.destroyed) {
            return;
        }

        this.destroyed = true;
        this.running = false;
        this.waitForCompletion = false;

        for (const worker of this.workers) {
            worker.worker.terminate();
        }
    }
}